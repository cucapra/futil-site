{
  "url_prefix": "https://raw.githubusercontent.com/cucapra/futil/master/",
  "categories": [
    {
      "name": "library",
      "items": [
        {
          "name": "Core",
          "file": "primitives/core.futil",
          "content": "extern \"core.sv\" {\n\n  /// Primitives\n  primitive std_reg<\"static\"=1>[width](\n    in: width, write_en: 1, clk: 1\n  ) -> (\n    out: width, done: 1\n  );\n  primitive std_const<\"share\"=1>[width, value]() -> (out: width);\n\n  /// Numerical operators\n  primitive std_lsh<\"share\"=1>[width](left: width, right: width) -> (out: width);\n  primitive std_rsh<\"share\"=1>[width](left: width, right: width) -> (out: width);\n  primitive std_add<\"share\"=1>[width](left: width, right: width) -> (out: width);\n  primitive std_sub<\"share\"=1>[width](left: width, right: width) -> (out: width);\n  primitive std_slice<\"share\"=1>[in_width, out_width](in: in_width) -> (out: out_width);\n\n  /// Logical operators\n  primitive std_not<\"share\"=1>[width](in: width) -> (out: width);\n  primitive std_and<\"share\"=1>[width](left: width, right: width) -> (out: width);\n  primitive std_or<\"share\"=1>[width](left: width, right: width) -> (out: width);\n  primitive std_xor<\"share\"=1>[p_width](left: p_width, right: p_width) -> (out: p_width);\n\n  /// Comparison operators\n  primitive std_gt<\"share\"=1>[width](left: width, right: width) -> (out: 1);\n  primitive std_lt<\"share\"=1>[width](left: width, right: width) -> (out: 1);\n  primitive std_eq<\"share\"=1>[width](left: width, right: width) -> (out: 1);\n  primitive std_neq<\"share\"=1>[width](left: width, right: width) -> (out: 1);\n  primitive std_ge<\"share\"=1>[width](left: width, right: width) -> (out: 1);\n  primitive std_le<\"share\"=1>[width](left: width, right: width) -> (out: 1);\n\n  /// Memories\n  primitive std_mem_d1[width, size, idx_size](\n    addr0: idx_size,\n    write_data: width,\n    write_en: 1,\n    clk: 1\n  ) -> (read_data: width, done: 1);\n\n  primitive std_mem_d2[width, d0_size, d1_size, d0_idx_size, d1_idx_size](\n    addr0: d0_idx_size,\n    addr1: d1_idx_size,\n    write_data: width,\n    write_en: 1,\n    clk: 1\n  ) -> (read_data: width, done: 1);\n\n  primitive std_mem_d3[\n      width,\n      d0_size,\n      d1_size,\n      d2_size,\n      d0_idx_size,\n      d1_idx_size,\n      d2_idx_size\n  ] (\n    addr0: d0_idx_size,\n    addr1: d1_idx_size,\n    addr2: d2_idx_size,\n    write_data: width,\n    write_en: 1,\n    clk: 1\n  ) -> (read_data: width, done: 1);\n\n  primitive std_mem_d4[\n      width,\n      d0_size,\n      d1_size,\n      d2_size,\n      d3_size,\n      d0_idx_size,\n      d1_idx_size,\n      d2_idx_size,\n      d3_idx_size\n  ] (\n    addr0: d0_idx_size,\n    addr1: d1_idx_size,\n    addr2: d2_idx_size,\n    addr3: d3_idx_size,\n    write_data: width,\n    write_en: 1,\n    clk: 1\n  ) -> (read_data: width, done: 1);\n\n\n  // ============= Unsynthesizable: External memory definitions ===============\n  primitive std_mem_d1_ext[width, size, idx_size](\n    addr0: idx_size,\n    write_data: width,\n    write_en: 1,\n    clk: 1\n  ) -> (read_data: width, done: 1);\n\n  primitive std_mem_d2_ext[width, d0_size, d1_size, d0_idx_size, d1_idx_size](\n    addr0: d0_idx_size,\n    addr1: d1_idx_size,\n    write_data: width,\n    write_en: 1,\n    clk: 1\n  ) -> (read_data: width, done: 1);\n\n  primitive std_mem_d3_ext[\n      width,\n      d0_size,\n      d1_size,\n      d2_size,\n      d0_idx_size,\n      d1_idx_size,\n      d2_idx_size\n  ] (\n    addr0: d0_idx_size,\n    addr1: d1_idx_size,\n    addr2: d2_idx_size,\n    write_data: width,\n    write_en: 1,\n    clk: 1\n  ) -> (read_data: width, done: 1);\n\n  primitive std_mem_d4_ext[\n      width,\n      d0_size,\n      d1_size,\n      d2_size,\n      d3_size,\n      d0_idx_size,\n      d1_idx_size,\n      d2_idx_size,\n      d3_idx_size\n  ] (\n    addr0: d0_idx_size,\n    addr1: d1_idx_size,\n    addr2: d2_idx_size,\n    addr3: d3_idx_size,\n    write_data: width,\n    write_en: 1,\n    clk: 1\n  ) -> (read_data: width, done: 1);\n\n}"
        }
      ]
    },
    {
      "name": "examples",
      "items": [
        {
          "name": "Seq",
          "file": "tests/correctness/seq.futil",
          "content": "component main() -> () {\n  cells {\n    in = prim std_mem_d1(32, 1, 1);\n    b = prim std_reg(32);\n    c = prim std_reg(32);\n    out = prim std_mem_d1(32, 1, 1);\n  }\n\n  wires {\n    group B<\"static\"=1> {\n      b.write_en = 1'b1;\n      in.addr0 = 1'b0;\n      b.in = in.read_data;\n      B[done] = b.done;\n    }\n\n    group C<\"static\"=1> {\n      c.write_en = 1'b1;\n      c.in = b.out;\n      C[done] = c.done;\n    }\n\n    group commit<\"static\"=1> {\n      out.write_en = 1'b1;\n      out.addr0 = 1'b0;\n      out.write_data = c.out;\n      commit[done] = out.done;\n    }\n  }\n\n  control {\n    seq {\n      B;\n      C;\n      commit;\n    }\n  }\n}"
        },
        {
          "name": "Par",
          "file": "tests/correctness/par.futil",
          "content": "component main() -> () {\n  cells {\n    a = prim std_mem_d1(32, 1, 1);\n    b = prim std_mem_d1(32, 1, 1);\n    c = prim std_mem_d1(32, 1, 1);\n  }\n\n  wires {\n    group wr_a<\"static\"=1> {\n      a.addr0 = 1'b0;\n      a.write_en = 1'b1;\n      a.write_data = 32'd1;\n      wr_a[done] = a.done;\n    }\n\n    group wr_b<\"static\"=1> {\n      b.addr0 = 1'b0;\n      b.write_en = 1'b1;\n      b.write_data = 32'd1;\n      wr_b[done] = b.done;\n    }\n\n    group wr_c<\"static\"=1> {\n      c.addr0 = 1'b0;\n      c.write_en = 1'b1;\n      c.write_data = 32'd1;\n      wr_c[done] = c.done;\n    }\n  }\n\n  control {\n    par {\n      wr_a;\n      wr_b;\n      wr_c;\n    }\n  }\n}"
        },
        {
          "name": "If",
          "file": "tests/correctness/if.futil",
          "content": "component main() -> () {\n  cells {\n    mem = prim std_mem_d1(32, 1, 1);\n    lt = prim std_lt(32);\n  }\n\n  wires {\n    group cond<\"static\"=0> {\n      lt.left = 32'd5;\n      lt.right = 32'd9;\n      cond[done] = 1'b1;\n    }\n\n    group true<\"static\"=1> {\n      mem.addr0 = 1'b0;\n      mem.write_data = 32'd4;\n      mem.write_en = 1'b1;\n      true[done] = mem.done;\n    }\n\n    group false<\"static\"=1> {\n      mem.addr0 = 1'b0;\n      mem.write_data = 32'b0;\n      mem.write_en = 1'b1;\n      false[done] = mem.done;\n    }\n  }\n\n  control {\n    if lt.out with cond {\n      true;\n    } else {\n      false;\n    }\n  }\n}"
        },
        {
          "name": "Infer",
          "file": "tests/passes/infer-static-timing.futil",
          "content": "// -p infer-static-timing\n\nimport \"primitives/std.lib\";\n\ncomponent main() -> () {\n  cells {\n    r0 = prim std_reg(1);\n    r1 = prim std_reg(1);\n\n    m0 = prim std_mem_d1(32, 1, 1);\n  }\n\n  wires {\n    group zero_cycles {\n      zero_cycles[done] = 1'd1;\n    }\n\n    group one_cycle {\n      r0.write_en = 1'd1;\n      one_cycle[done] = r0.done;\n    }\n\n    group two_cycles {\n      r0.write_en = 1'd1;\n      r1.write_en = r0.done;\n      two_cycles[done] = r1.done;\n    }\n\n    // no static timing info for memories; bail out\n    group mem_wrt_to_done {\n      m0.addr0 = 1'd0;\n      m0.write_data = 32'd5;\n      m0.write_en = 1'd1;\n      mem_wrt_to_done[done] = m0.done;\n    }\n\n    // bail out when there are multiple writes to a done port\n    group mult_wrts_to_done {\n      r0.write_en = 1'd1;\n      mult_wrts_to_done[done] = r0.done ? 1'd1;\n    }\n  }\n\n  control {\n    seq {\n      zero_cycles;\n      one_cycle;\n      two_cycles;\n      mem_wrt_to_done;\n      mult_wrts_to_done;\n    }\n  }\n}"
        }
      ]
    }
  ]
}
